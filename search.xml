<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c# asp.net之ashx写webRestful接口]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04-c%23%20asp.net%E4%B9%8Bashx%E5%86%99webRestful%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[c# asp.net之ashx写webRestful接口&lt;% img /public/images/create-project.1.png %&gt; 使用vs2019创建项目 打开vs2019，点击顶部tabs 文件 –&gt; 新建 –&gt; 项目 &lt;% img /public/images/create-project.1.png %&gt; 12 如果在字符串的左引号前添加$，则可以在大括号之间的字符串内包括变量1Console.WriteLine($&quot;i am &#123;name&#125;&quot;); 字符串去除两端空格 12345// 字符去除两端空格//name = name.Trim();//name = name.TrimStart();name = name.TrimEnd();Console.WriteLine($&quot;[&#123;name&#125;&quot;; 替换字符串的字符 123string str = &quot;all is well&quot;;str = str.Replace(&quot;is&quot;, &quot;was&quot;);Console.WriteLine(str); 查找字符串文本 12345678// 查找字符串中的文本string str = &quot;zander&quot;;Console.WriteLin(str.Contains(&quot;a&quot;));// 在字符串开始和结束搜索字符string str = &quot;You say goodbye, and I say hello&quot;;Console.WriteLine(str.StartsWith(&quot;You&quot;));Console.WriteLine(str.StartsWith(&quot;and&quot;)); 比较字符串 修改字符串内容 确定字符串是否表示数字 分隔字符串 将多个字符串合并成一个字符串 在字符串中搜索文本]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>ashx</tag>
        <tag>restful</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#程序结构]]></title>
    <url>%2F2019%2F05%2F07%2F2019-05-07-c%23-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[C#程序结构 C#中的程序结构包括：程序，命名空间，类型，成员，程序集 12345678910111213141516171819202122232425262728293031323334using System;namespace Acme.Collections&#123; public class Stack &#123; Entry top; public void Push(object data) &#123; top = new Entry(top, data); &#125; public object Pop() &#123; if (top == null) &#123; throw new InvalidOperationException(); &#125; object result = top.data; top = top.next; return result; &#125; class Entry &#123; public Entry next; public object data; public Entry(Entry next, object data) &#123; this.next = next; this.data = data; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#处理字符串]]></title>
    <url>%2F2019%2F05%2F07%2F2019-05-08-c%23%20%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[C#处理字符串Hello World 字符串内插 如果在字符串的左引号前添加$，则可以在大括号之间的字符串内包括变量 1Console.WriteLine($&quot;i am &#123;name&#125;&quot;); 字符串去除两端空格 12345// 字符去除两端空格//name = name.Trim();//name = name.TrimStart();name = name.TrimEnd();Console.WriteLine($&quot;[&#123;name&#125;&quot;; 替换字符串的字符 123string str = &quot;all is well&quot;;str = str.Replace(&quot;is&quot;, &quot;was&quot;);Console.WriteLine(str); 查找字符串文本 12345678// 查找字符串中的文本string str = &quot;zander&quot;;Console.WriteLin(str.Contains(&quot;a&quot;));// 在字符串开始和结束搜索字符string str = &quot;You say goodbye, and I say hello&quot;;Console.WriteLine(str.StartsWith(&quot;You&quot;));Console.WriteLine(str.StartsWith(&quot;and&quot;)); 比较字符串 修改字符串内容 确定字符串是否表示数字 分隔字符串 将多个字符串合并成一个字符串 在字符串中搜索文本]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows power shell 常用命令]]></title>
    <url>%2F2019%2F05%2F06%2F2019-05-06-windows%20power%20shell%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Windows power shell 常用命令 德心孤必有邻，心怀志定创业！ 创建文件 1new-item filesname.cs 创建文件夹 1new-item directoryname -type derictory 删除文件 1234567891011// 删除目录下指定的文件remove-item c:/directoryname filesname.cs// 删除目录下所有的文件remove-item c:/directoryname/*// 删除---排除某类型文件remove-item c:/directoryname/* -exclude *.cs// 仅仅删除某种类型文件remove-item c:/directoryname/* -include *.cs 打开文件 123// .\文件名.扩展名.\filesname.cs]]></content>
      <categories>
        <category>windows</category>
        <category>power shell</category>
      </categories>
      <tags>
        <tag>power shell</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6‘...’rest和三点扩展运算符]]></title>
    <url>%2F2019%2F01%2F08%2F2019-01-08-ES6...rest%E5%92%8C%E4%B8%89%E7%82%B9%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[ES6 的 rest 参数和扩展运算符扩展运算符 含义 扩展运算符是三个点(…)，它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 123console.log(1, ...[2, 3, 4], 5); // 1,2,3,4,5[...document.querySelectorAll('all')] // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 扩展运算符主要是结合普通函数使用 12345678// 普通函数一起使用function fun(a, b, c, d, e)&#123;&#125;const args = [0, 2]fun(-1, ...args, 2, ...[3])// 扩展运算符后面还可以放置表达式cosnt arr = [ ...(x &gt; 0 ? ['x'] : []), 'y'] 替代函数的 apply 方法 12345678910// ES5 是写法function fun(x, y, z)&#123; // ...&#125;var args = [0, 1, 2]fun.apply(null, args)// ES6 的写法let args = [2, 3, 4]fun(...args) 合并或者连接数组 12345678let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]// 代替push方法arr1.push(...arr2)// 代替concat方法[...arr1, ...arr2] 复制数组 123const arr1 = [1, 2, 3];// 将arr1复制给arr2const arr2 = [...arr1]; 解构赋值 123456// ES5let x = arr[0];let restArr = arr.slice(1)// ES6let [x, ...restArr] = arr; 字符串转化成数组 12let str = 'Hello World'const arr = [...str] 类数组转数组 1234let nodeList = document.querySelect('div')let nodeArr = [...nodeList]// 只可以将可以枚举的类数组对象转换成数组 map 和 Set 结构 1234// 数组去重[...new Set(arr)]// map]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 本地对象和内置对象 && Browser 对象 && HTML DOM 对象]]></title>
    <url>%2F2019%2F01%2F08%2F2019-01-08-JavaScript%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8CWindows%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JavaScript 本地对象和内置对象 &amp;&amp; Browser 对象 &amp;&amp; HTML DOM 对象 JavaScript 本地对象和内置对象 Array Boolean String Date MAth Number RegExp Global Browser BOM 对象 window Navigator Screen History Location HTML DOM 对象 Document Element Attribute Event]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM 事件详解]]></title>
    <url>%2F2019%2F01%2F08%2F2019-01-08-DOM%20Event%20(%E4%BA%8B%E4%BB%B6)%2F</url>
    <content type="text"><![CDATA[DOM 事件基本概念 DOM 使 JavaScript 有能力怼 HTML 上的事件做出反应。DOM事件的级别： DOM0 element.onclick = function(){} DOM2 element.addEventListener(“click”, function(){}) DOM3 element.addEventListener(“keyup”, function(){}) DOM 事件模型 DOM 事件模型分为两种，一类是 IE 的冒泡事件模型，另一类是 DOM 标准定义的冒泡型与捕获型的事件。 DOM 事件流事件流： window -&gt; 捕获 -&gt; 目标阶段 -&gt; 冒泡 -&gt; window 描述 DOM 事件捕获的具体流程 Event 对象的常见应用12345event.preventDefault() // 阻止默认事件event.stopPropagation() // 阻止事件冒泡event.stopImmediatePropagation() // 事件响应优先级event.currentTarget // 当前绑定的事件对象event.target 自定义事件js 的观察者模式创建自定义事件 Event()构造函数，创建一个新的事件对象 event CustomEvent()创建一个自定义事件 document.CreateEvent()创建一个新的事件对象 event，随之必须调用自身的 init 方法进行初始化 12345678910// 创建事件var create = document.createEvent("Event")// 定义事件名为'build'create.initEvent("build", true, true)// 监听事件element.addEventListener("buiild", function(e)&#123; console.log(e.target)&#125;, false)// 出发对象可以是任何元素或者其他事件目标element.dispatchEvent(event) 自定义事件封装123456789101112131415161718192021(function()&#123; try&#123; // a : While a window.CustomEvent object exists, it cannot be called as a constructor. // b : There is no window.CustomEvent object new window.CustomEvent('T'); &#125;catch(e)&#123; var CustomEvent = function(event, params)&#123; params = params || &#123; bubbles: false, cancelable: false, detail: undefined &#125;; var evt = document.createEvent('CustomEvent'); evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail); return evt; &#125;; CustomEvent.prototype = window.Event.prototype; window.CustomEvent = CustomEvent; &#125;&#125;)();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 本地对象和内置对象 && Browser 对象 && HTML DOM 对象]]></title>
    <url>%2F2019%2F01%2F08%2F2019-01-09-sass%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[sass 中文文档 sass css 预编译器，是由按强化 css 的工具。 sass 特点 完美兼容 css3 在 css 基础上增加了变量，嵌套（nesting）,混合（mixins）,导入（import）; 通过函数进行颜色值与属性值的计算 提供控制指令等高级功能 自定义输出格式 css 功能扩展 嵌套规则 Sass 允许将一套 css 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器 123456header &#123; color: red; nav &#123; font-size: 14px; &#125;&#125; 父选择器 &amp; 用&amp;代表嵌套规则外层的父选择器 123456a &#123; color: blue; &amp;:hover &#123; color: red; &#125;&#125; 属性嵌套 为了方便管理复杂的属性，同时也为了避免重复的输入，Sass 允许将属性嵌套在命名空间中 1234567.funky &#123; font &#123; family: fantasy; size: 15px; weight: bold; &#125;&#125; 注释： /* */ 与 // Sass 支持标准的 css 多行注释/* */，以及单行注释 //, 前者会被完整输出到编译后的 css 文件中，而后者则不会 1234567891011121314/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black;&#125;// These comments are only one line long each.// They won't appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green;&#125; SassScript 变量 $ (Variable: \$) SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 css 属性的写法一样 12345678910111213// 变量声明$width: 100px;// 调用方式.box &#123; width: $width;&#125;// 将局部变量转换为全局变量可以在其后添加 !global.box &#123; $width: 100px !global; width: $width;&#125; 数据类型 SassScript 支持 6 中主要的数据类型 数字 字符串 颜色 布尔值 true/false 空值，null 数组 maps 2.1 字符串 有引号字符串和无引号字符串；使用字符串变量的方式： #{} 运算 所有数据类型均支持相等运算 == 或 !=，此外，每种数据类型也有其各自支持的运算方式。 数字运算 SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值 12345678p &#123; font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5) / 2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division&#125; 圆括号用来影响运算的顺序 函数指令 Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用： 12345678910$grid-width: 40px;$gutter-width: 10px;@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;#sidebar &#123; width: grid-width(5);&#125; @-Rules 与指令 (@-Rules and Directives) @import Sass 拓展了@import 的功能，允许其导入 SCSS 或 SaSS 文件。被导入的文件将合并编译到同一个 css 文件中，另外，被导入的文件中所包含的变量或者混合指令（mixin）都可以在导入的文件中使用。 嵌套@import 12345678910// 假设 example.scss 文件包含以下样式：.example &#123; color: red;&#125;// 然后导入到 #main 样式内#main &#123; @import 'example';&#125; @media @extend 在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式 12345678.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 混合指令（Mixin Directives） 混合指令（Mixin）用于定义可重复使用的样式，避免了使用无意的 class，比如.float-left。混合指令可以包含所有的 css 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。 定义混合指令 @mixin (Defining a Mixin: @mixin) 12345678910111213@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: '.'; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px; &#125;&#125; 使用 Mixin 样式： @include 使用@include之快令引入混合样式，格式是在其后添加混合名称 12345.page-title &#123; @include clearfix; padding: 4px; margin-top: 10px;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue之scoped css]]></title>
    <url>%2F2018%2F12%2F25%2F2018-12-25-vue%E4%B9%8B%20scoped%20css%2F</url>
    <content type="text"><![CDATA[Scoped CSS 详解 当&lt;style&gt;标签有scoped属性时，它的 CSS 只作用于当前组件中的元素，这类似与 Shadow DOM 中的样式封装。他有一些注意事项，但不许任何 polyfill。它通过 PostCSS 来实现以下转换 123456789&lt;style scoped&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;example&quot;&gt;hi&lt;/div&gt;&lt;/template&gt; 子组件的根元素 使用scoped后，父组件的样式将不会渗透到子组件中。不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件 scoped CSS 的影响。这样涉及是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。 深度作用选择器 如果你希望scoped样式中的一个选择器能够作用得更深，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符： 123&lt;style scoped&gt; .a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt; 上述的代码会被编译成： 123.a[data-v-f3f3eg9] .b &#123; /* ... */&#125; 有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用/deep/ 操作符取而代之这个&gt;&gt;&gt;的别名，同样可以正常工作 动态生成的内容 通过v-html创建的 DOM 内容不受 Scoped 样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[计算机组成原理 https://blog.csdn.net/Adjerrekaf/article/details/78880089 计算机系统组成？ 软件 硬件 计算机系统 5 层层次结构从下到上？ 微程序机器 —-&gt; 传统机器 —–&gt; 操作系统机器 ——&gt; 汇编语言机器 —-&gt; 高级语言机器——-微程序机器和传统机器是物理机， 其他的都是虚拟机 在计算机系统结构中，什么是解释，什么是翻译？ 翻译： 将一种语言编写的程序全部翻译程另外一种语言，然后执行 解释： 将一种语言编写的程序一条语句翻译成另一种语言的一条或者多条语句，然后执行，执行完这条语句后，然后再解释下一句； 电子计算机的基本结构形式： 冯诺伊曼机： 运算器 + 控制器 + 存储器 + 输入设备 + 输出设备 特征： 数字计算机的机制采用二进制；计算机应该按照程序顺序执行； 什么是存储单元，存储字，存储子长，存储体？ 存储单元： 存储一个存储字并具有特定存储地址的存储单位 存储字：一个存储单元中存放的所有二进制数据，按照某个地址访问某个存储单元获取的二进制数据 存储字长：存储字中二进制的位数，即按照某个地址访问某个存储单元获取的二进制数据的位数； 由多个存储单元构成的存储器件 主存储器中，什么是 MAR，什么是 MDR，存储器的最大容量由什么决定？ MAR： 存储地址寄存器，保存需要访问的存储单元地址。反应存储单元的个数 MDR： 存储数据寄存器，缓存读出/写入存储单元的数据。反应存储字长- 什么是机器字长，什么是存储字长？ 机器字长：CPU 一次能够处理的二进制数据的位数 存储字长：按照某个地方访问某个存储单元获取的二进制数据的位数]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>计算机科学</tag>
        <tag>计算理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-10-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局 假设高度已知，请写出三栏布局，其中左右栏各 300px，中间自适应 浮动 双飞翼布局/圣杯布局 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;圣杯布局&lt;/title&gt; &lt;style&gt; .container &#123; overflow: hidden; &#125; .center &#123; width: 100%; height: 300px; background-color: red; &#125; .left, .right &#123; float: left; width: 200px; height: 300px; background-color: black; &#125; .right &#123; float: right; margin-left: -200px; background-color: brown; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 定位 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;双飞翼布局&lt;/title&gt; &lt;style lang="css"&gt; .container &#123; overflow: hidden; position: relative; &#125; .center &#123; width: 100%; height: 300px; background-color: red; &#125; .left, .right &#123; width: 200px; height: 300px; position: absolute; top: 0; &#125; .left &#123; left: 0; background-color: aqua &#125; .right &#123; right: 0; background-color: blue &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex 布局 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;flex布局&lt;/title&gt; &lt;style&gt; .container &#123; display: flex; &#125; .center &#123; flex: 1; height: 300px; background-color: red; &#125; .left, .right &#123; width: 200px; background-color: lawngreen; height: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 4.table 布局 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;table布局&lt;/title&gt; &lt;style&gt; .container &#123; display: table; &#125; .center &#123; display: table-cell; width: 100%; height: 300px; background-color: yellow; &#125; .left, .right &#123; width: 200px; height: 300px; background-color: brown; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 5.网格布局 Grid 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Grid网格布局&lt;/title&gt; &lt;style&gt; .container &#123; display: grid; grid-template-columns: 200px auto 200px; grid-template-rows: 300px; &#125; .center &#123; background-color: red; &#125; .left, .right &#123; background-color: brown; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="center"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期详解]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-10-vue%20the%20life%2F</url>
    <content type="text"><![CDATA[vue2.0 生命周期详解 参考链接 阶段 状态 beforeCreate el 和 data 并未初始化 created 完成了 data 数据初始化，但是 el 并没有 beforeMount 完成了 el 和 data 数据初始化 mounted 完成挂载 beforeUpdate data 变化时会被触发 updated data 变化时会被触发 beforeDestroy 实例销毁前调用，依然可以使用 destroyed 对 data 的方法不会再出发周期函数，说明此时 vue 实例已经接触了事件监听和 dom 的绑定，但是 dom 依然存在 参考链接]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6...rest和三点扩展运算符]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-10-ES6%20REST%2F</url>
    <content type="text"><![CDATA[ES6 的 rest 参数和扩展运算符扩展运算符 含义 扩展运算符是三个点(…)，它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 123console.log(1, ...[2, 3, 4], 5); // 1,2,3,4,5[...document.querySelectorAll('all')] // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 扩展运算符主要是结合普通函数使用 12345678// 普通函数一起使用function fun(a, b, c, d, e)&#123;&#125;const args = [0, 2]fun(-1, ...args, 2, ...[3])// 扩展运算符后面还可以放置表达式cosnt arr = [ ...(x &gt; 0 ? ['x'] : []), 'y'] 替代函数的 apply 方法 12345678910// ES5 是写法function fun(x, y, z)&#123; // ...&#125;var args = [0, 1, 2]fun.apply(null, args)// ES6 的写法let args = [2, 3, 4]fun(...args) 合并或者连接数组 12345678let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]// 代替push方法arr1.push(...arr2)// 代替concat方法[...arr1, ...arr2] 复制数组 123const arr1 = [1, 2, 3];// 将arr1复制给arr2const arr2 = [...arr1]; 解构赋值 123456// ES5let x = arr[0];let restArr = arr.slice(1)// ES6let [x, ...restArr] = arr; 字符串转化成数组 12let str = 'Hello World'const arr = [...str] 类数组转数组 1234let nodeList = document.querySelect('div')let nodeArr = [...nodeList]// 只可以将可以枚举的类数组对象转换成数组 map 和 Set 结构 1234// 数组去重[...new Set(arr)]// map]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ES6</tag>
        <tag>array</tag>
        <tag>rest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array 数据相关处理方式]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-10-Array%20design%2F</url>
    <content type="text"><![CDATA[数组相关 数据去重，排序等等处理方式 数组去重 filter 123Array.filter(function(val, index, arr)&#123; return Array.indexOf(val) === index;&#125;) ES6 123456// 标准实现方法Array.from(new Set(arr));// 扩展运算符[...new Set(arr)] reduce 1234567let result = arr.sort().reduce((init, current) =&gt; &#123; if(init.length === 0 || init[init.length - 1] != current)&#123; init.push(current); &#125; return init;&#125;, []) push 12345678let tempArray = []for(var i = 0; i &lt; arr.length; i++)&#123; (function(i)&#123; if(tempArrray[i].indexOf(arr[i] === -1))&#123; tempArray.push(aarr[i]) &#125; &#125;(i))&#125; 排序去除相邻的重复元素 1234567let sortArray = arr.sort()let tempArray = []for(var i = 0; i &lt; arr.length; i++)&#123; if(sortArray[i] != sortArray[i+1])&#123; tempArray.push(sortArray[i]) &#125;&#125; splice 12345678910var len = arr.length;for(let i = 0; i &lt; len; i++) &#123; for(let j = i + 1; j &lt; len; j++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(i,1); len--; j--; &#125; &#125;&#125; 判断是否是数组12345// JavaScript新增API isArrayArray.isArray(arr);// 使用原型链Object.prototype.toString.call(arr).split(" ")[1].slice(0, -1) 可枚举的对象转化成数组1234567[].slice.call(obj)[].slice.apply(obj, [0])Array.prototype.slice.call(obj)Array.prototype.slice.apply(obj, [0])// Array.prototype.push.apply(obj.arguments)[第五个方法参考资料](https://www.quora.com/How-does-Array-prototype-push-apply-work-in-JavaScript) 数组对象排序123456789101112131415161718192021222324var sortBy = function(attr, rev)&#123; // attr 排序的属性，rev排序的方式 // 如果第二个参数如果没有传，默认是升序排列 if(rev == undefind)&#123; rev = 1; &#125;else &#123; rev = (rev) ? 1 : -1; &#125; return function (a, b)&#123; a = a[attr]; b = b[attr]; if(a &lt; b)&#123; return rev * -1; &#125; if(a &gt; b) &#123; return rev * 1; &#125; return 0; &#125;&#125;Array.sort(sortBy("number", false))]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 盒模型]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-10-css%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[css 盒模型… 基本概念 css 盒模型(Box Model)规定了元素框处理元素的内容，边框，内边距，外边距的方式。 W3C 标准模型和 IE 盒模型 W3C 标准盒模型：属性 width 和 height 只包含 content，不包含 border 和 paddingIE 盒模型：属性 width 和 height 包含 content+padding+border css 如何设置这两种模型 ie8+浏览器中的盒模型可以由 box-sizing 进行自由切换centent-box 标准盒模型，border-box IE 盒模型 js 如何设置获取盒模型对应的宽和高 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;js如何获取css盒模型的宽和高&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; width: 100px; height: 100px; padding: 50px; border: 5px solid red; margin: 50px; &#125; &lt;/style&gt; &lt;div id="box" style=""&gt;&lt;/div&gt; &lt;script&gt; let box = document.getElementById('box') // 只能取到内联样式的宽高 console.log('style:' + box.style.width) // 100px // 内联样式和外联样式的宽高都能取到，但只有 IE 支持 console.log('currentStyle:' + box.currentStyle.width) // 100px // 内联样式和外联样式的宽高都能取到，几乎所有主流浏览器都支持 console.log('getComputedStyle:' + getComputedStyle(box).width) // 100px // 内联样式和外联样式的宽高都能取到，几乎所有主流浏览器都支持，取到的是盒子总宽度 console.log( 'getBoundingClientRect:' + box.getBoundingClientRect().width ) // 210 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 根据盒模型解释边距重叠 BFC(边距重叠解决方案)BFC概念 ： 块级格式化上下文如何创建BFC：_ float 的值不为 none_ overflow 的值不为 visiable_ display 的值为 inline-block，table-caption，table-cell_ position 的值为 absolute，fixedBFC作用：_ 自适应两栏布局_ 可以阻止元素被浮动元素覆盖_ 可以包含浮动元素，清除内部浮动_ 分属于不同的 BFC 可以阻止 margin 重叠BFC的原理：_ 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠_ BFC 的区域不会与 float box 重叠_ BFC 在页面上是一个独立的容器._ ji 算 BFC 的高度时间，浮动元素也要跟着计算 …]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>HTML5</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在浏览器输入 URL 到页面加载发生了什么？]]></title>
    <url>%2F2018%2F12%2F19%2F2018-12-17-%E4%BB%8E%E8%BE%93%E5%85%A5URl%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在浏览器输入 URL 到页面加载发生了什么？过程综述： DNS 解析 TCP 连接 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 连接结束 一. DNS 解析 wiki介绍: 域名系统（domain name system，缩写：DNS）是互联网的一项服务。它作为将域名和 ip 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS 使用 TCP 和 UDP 端口 53.当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能朝服哦 253 个字符。最基本的作用就是将域名翻译成对应的 IP 地址 域名解析过程 检查缓存 浏览器缓存 用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对用的 ip 地址（若曾经访问过，没有被清除，就会存在） 系统缓存 检查系统的 hosts 文件有没有这个域名的映射，如果有，直接返回 ISP（互联网服务提供商）DNS 缓存 如果 hosts 与本地的 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 根域名服务器 当以上均未完成，则进入根服务器查询，全球仅有 13 台服务器，1 个根域名服务器，其余 12 台为辅助域名服务器。根域名收到请求后会查询域名文件记录，若无则将其管辖的顶级域名（如： .com）服务器 IP 告诉本地 DNS 服务器 顶级域名服务器 顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器 IP 地址告诉本地服务器 主域名服务器 主域名服务器接收到请求以后查询自己的缓存，如果没有则进入下一级域名服务器查找，并重复该步骤直至找到正确记录 保存结果到缓存 本地域名服务器吧返回的结果保存到缓存 &lt;% img /public/images/dns.jpg %&gt; 二. TCP 链接 第一次握手：CLient 将标识位 SYN 置为 1，随机产生一个值 seq=j，并将该数据包发送至 Server，Client 进入 SYN_SEND 状态，等待 Server 确认。 第二次握手：Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立链接，Server 将标识位 SYN 和 ACK 都置为 1，ACK=j+1，随机产生一个值 seq=K，并将该数据包发送给 Client 以确认连接请求。 第三次握手：Client 收到确认后，检查 ACK 是否为 j+1，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，ACK=k+1,并将该数据发送给 Server，Server 检查 ACK 是否为 k+1,ACK 是否为 1，如果正确则建立连接成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。 三. HTTP 请求 发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送服务器指定端口（HTTP 协议 80/8080，HTTPS 协议 443）.HTTP 请求报文由三部分组成： 请求头，请求行，请求体 四. 服务器处理请求返回 HTTP 报文 后端从在固定的端口接收到 TCP 报文开始，这一部分对于编程语言中的 socket。他会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。HTTP 响应报文包括三部分：状态码，响应报头，响应报文 五. 浏览器解析渲染页面 浏览器是一个边间谍西边渲染的过程。首先浏览器解析 HTML 文件构成 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Itwebbers 随想录</tag>
        <tag>UX/UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个你说不上来的URL详解]]></title>
    <url>%2F2018%2F12%2F19%2F2018-12-17-what%20is%20the%20url%2F</url>
    <content type="text"><![CDATA[url 统一资源定位符（或程统一资源定位器/定位位置/URL 等）[Unifrom Reasource Locator, 缩写：URL]，有时也称作是网页地址（网址）。 统一资源定位符的标准格式如下： 协议类型：[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件]文件名[?查询][#片段ID]http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument 传输协议，例如 HTTP 层级 URL 标记傅好（为[//],固定不改变） 访问资源需要的凭证信息（可以省略） 服务器（通常域名，有时间为 IP 地址） 端口号（以数字的形式表示，若为 HTTP 默认，“:80”可以省略） 路径（以’/‘字符区别路径中的每一个目录名称） 参数： （GET 模式的窗体参数，以’？’字符为起点，每个参数以’&amp;’隔开，再以=分开参数名称与数据，通常以 UTF-8 的 URL 编码，避开字符冲突的问题） 片段： 以#字符为起点是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。例如，在 HTML 文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚代表的时间。值得注意的是，＃后面的部分（也称为片段标识符）从来没有发送到请求的服务器。 linTo什么是 URL？]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex 布局]]></title>
    <url>%2F2018%2F12%2F18%2F2018-12-18-flex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flex 布局 1 容器 1.1 父容器 1.2 子容器 2 轴 2.1 主轴 2.2 交叉轴 flex 的核心概念就是容器和轴。容器包括外层的父容器和内层的子容器，轴包括主轴和交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 css 属性（不含 display： flex），其中父容器和子容器各 6 个。不过常用的属性只有 4 个，父容器，子容器各 2 个。 容器 父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。 &lt;% img /public/images/flex 容器.jpg %&gt; 父容器 设置子容器沿主轴排列：justify-content 属性应用于定义如何沿着主轴方向排列子容器 &lt;% img /public/images/justify-content.jpg %&gt; flex-start: 沿着主轴方向起端对齐开始 display: flex justify-content: flex-start #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; justify-content: flex-start;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; flex-end: 沿着主轴方向末端对齐 display: flex justify-content: flex-end #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; justify-content: flex-end;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; center: 沿着主轴方向剧中对齐 display: flex justify-content: center #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; justify-content: center;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; space-around: 子容器沿主轴均匀分布，位于首末两端的子容器到父容器的距离是子容器间距的一半 display: flex justify-content: space-around #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; justify-content: space-around;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; space-between: 子容器沿着主轴均匀分布，位于首位两端的子容器和父容器其相切 display: flex justify-content: space-between #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; justify-content: space-between;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; 设置子容器如何沿着交叉轴排列： align-items align-items 属性用于定义如何沿着交叉轴方向分配子容器的间距 flex-start: 在交叉轴的始端对齐 display: flex align-items: flex-start #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; align-items: flex-start;heihgt: 100%'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 60px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 40px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; flex-end: 沿着交叉轴的末端对齐 display: flex align-items: flex-end #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; align-items: flex-end;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 60px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 40px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; center: 沿着交叉轴方向剧中对齐 display: flex align-items: center #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; align-items: center;'&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 60px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;height: 40px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; baseline： 基线对齐，这里的 baseline 默认是指首行文字，即first baseline，所以子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。 display: flex align-items: baseline #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; align-items: baseline;'&gt; &lt;div style='color: #fff;line-height: 30px;height: 40px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;height: 80px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;height: 30px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; stretch: 子容器沿着交叉轴方向的尺寸拉伸至与父容器 display: flex align-items: stretch #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex; align-items: stretch;'&gt; &lt;div style='color: #fff;line-height: 40px;width:100px;background-color: red'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;width:100px;background-color: skyblue'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;width:100px;background-color: blue'&gt;#son3&lt;/div&gt;&lt;/div&gt; 子容器 在主轴上如何伸缩： flex display: flex #son1 flex: 1 #son2 flex:2 #son3flex: 1 12345&lt;div class='flex-container' style='text-align: center;display: flex; justify-content: flex-start;'&gt; &lt;div style='color: #fff;background-color: red; flex:1'&gt;#son1 &lt;br&gt;flex: 1&lt;/div&gt; &lt;div style='color: #fff;background-color: skyblue; flex: 2'&gt;#son2 &lt;br&gt;flex:2&lt;/div&gt; &lt;div style='color: #fff;background-color: blue;flex:1'&gt;#son3&lt;br&gt;flex: 1&lt;/div&gt;&lt;/div&gt; 单独设置子容器如何沿着交叉轴排列: align-self 每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器align-items属性完全一直,如果两者同时设置则以子容器align-self属性为准 flex-start：沿着交叉轴起始端开始对齐 display: flex align-items: center #son1 align-self: flex-start #son2 #son3 12345&lt;div class='flex-container' style='display: flex;align-items: center'&gt; &lt;div style='color: #fff;line-height: 40px;background-color: red;align-self: flex-start'&gt;#son1 &lt;br&gt;align-self: flex-start&lt;/div&gt; &lt;div style='color: #fff;line-height: 40px;background-color: skyblue;'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 40px;background-color: blue;'&gt;#son3&lt;/div&gt;&lt;/div&gt; flex-end: 沿着交叉轴末尾端对齐 display: flex align-items: center #son1align-self: flex-end #son2 #son3 12345&lt;div class='flex-container' style='display: flex;align-items: center'&gt; &lt;div style='color: #fff;line-height: 40px;background-color: red;align-self: flex-end'&gt;#son1&lt;br&gt;align-self: flex-end&lt;/div&gt; &lt;div style='color: #fff;line-height: 40px;background-color: skyblue;'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 40px;background-color: blue;'&gt;#son3&lt;/div&gt;&lt;/div&gt; center： 沿着交叉轴方向剧中对齐 display: flex align-items: flex-start #son1align-self: center #son2 #son3 12345&lt;div class='flex-container' style='display: flex;align-items: flex-start'&gt; &lt;div style='color: #fff;line-height: 40px;background-color: red;align-self: center'&gt;#son1&lt;br&gt;align-self: center&lt;/div&gt; &lt;div style='color: #fff;line-height: 40px;background-color: skyblue;'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 40px;background-color: blue;'&gt;#son3&lt;/div&gt;&lt;/div&gt; baseline: 基线对齐 display: flex #son1 #son2 #son3 12345&lt;div class='flex-container' style='display: flex;'&gt; &lt;div style='color: #fff;line-height: 40px;height: 60px;width:100px;background-color: red; align-self: baseline;'&gt;#son1&lt;/div&gt; &lt;div style='color: #fff;line-height: 60px;height: 100px;width:100px;background-color: skyblue; align-self: baseline;'&gt;#son2&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;height: 40px;width:100px;background-color: blue; align-self: baseline;'&gt;#son3&lt;/div&gt;&lt;/div&gt; stretch: 拉伸对齐 display: flex #son1align-self: stretch #son2 #son3 轴 轴包括主轴和交叉轴,我们都知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定 主轴 主轴的起端由flex-start标识，末端由flex-end表示，不同的主轴后防线对应的起始端和末尾端的位置也是不相同的 改变主轴的方向向右： flex-direction: row display: flex flex-direction: row #son1 flex: 1 #son2 flex: 2 #son3flex: 1 12345&lt;div class='flex-container' style='display: flex; flex-direction: row'&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: red'&gt;#son1&lt;br&gt; flex: 1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 2;background-color: skyblue'&gt;#son2&lt;br&gt; flex: 2&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: blue'&gt;#son3&lt;br&gt;flex: 1&lt;/div&gt;&lt;/div 改变主轴的方向向下： flex-direction: column display: flex flex-direction: column #son1 flex: 1 #son2 flex: 1 #son3flex: 1 12345&lt;div class='flex-container' style='display: flex; flex-direction: column'&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: red'&gt;#son1&lt;br&gt; flex: 1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: skyblue'&gt;#son2&lt;br&gt; flex: 1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: blue'&gt;#son3&lt;br&gt;flex: 1&lt;/div&gt;&lt;/div&gt; 向左： flex-direction： row-reverse display: flex flex-direction: row-reverse #son1 flex: 1 #son2 flex: 2 #son3flex: 1 12345&lt;div class='flex-container' style='display: flex; flex-direction: row-reverse'&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: red'&gt;#son1&lt;br&gt; flex: 1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 2;background-color: skyblue'&gt;#son2&lt;br&gt; flex: 2&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: blue'&gt;#son3&lt;br&gt;flex: 1&lt;/div&gt;&lt;/div&gt; 向右： flex-direction: column-reverse display: flex flex-direction: column-reverse #son1 flex: 1 #son2 flex: 1 #son3flex: 1 12345&lt;div class='flex-container' style='display: flex; flex-direction: column-reverse'&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: red'&gt;#son1&lt;br&gt; flex: 1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: skyblue'&gt;#son2&lt;br&gt; flex: 1&lt;/div&gt; &lt;div style='color: #fff;line-height: 30px;flex: 1;background-color: blue'&gt;#son3&lt;br&gt;flex: 1&lt;/div&gt;&lt;/div&gt; 交叉轴 主轴沿着逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾端也由 flex-start 和 flex-end 表示 LinkTo 一劳永逸的搞定 flex 布局]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速判断浏览器的版本和型号]]></title>
    <url>%2F2018%2F12%2F17%2F2018-12-17-%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E5%92%8C%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[快速判断浏览器的版本和型号 IE 浏览器 123&lt;!--[if IE 8]&gt; &lt;div&gt;您的历览器版本太低，请升级/切换至更高版本&lt;/div&gt;&lt;![endif]--&gt; safari 浏览器 1var isSafari = /a/._proto_==&quot;//&quot;; chrome 1var isChrome = Boolean(window.chrome);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>UX/UI</tag>
        <tag>🇬🇧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON Web Tokens 中文文档]]></title>
    <url>%2F2018%2F12%2F12%2F2018-12-15-JSON%20Web%20Token%2F</url>
    <content type="text"><![CDATA[什么是 JSON web Token？ JSON web Token (JWT) 是开放标准（[RFC 7591](https://tools.ietf.org/html/rfc7519)）,它定义了一种紧凑且独立的方式，可以在各个端之间作为 JSON 对象安全的传输信息。此信息可以通过数字签名进行验证和信任。JWT 可以使用一种加密方式（例如：使用 HMAC 算法）或使用 RSA 或 ECDSA 的公钥/私钥进行签名。 虽然JWT可以加密在各个端之间提供保密，但我们将专注于签名的token。签名的token可以验证其中包含的声明的完整性，而加密令牌则隐藏其他地方的声明。当使用公钥/私钥对签署令牌时，签名还要证明只有持有私钥的一方是签署私钥的一方。 JSON web Token 的使用场景 授权: 这是使用 JWT 的最常见方案，一旦用户登陆，每个后续请求将包含 JWT，允许用户访问该令牌的路由，服务和资源。Single Sign On 是一种现在广泛使用 JWT 的功能，因为它们的开销小，并且能够在不同的域中轻松使用（跨域）。 信息交换： JSON web Token 是在各方之间安全传输信息的好方法。因为 JWT 可以签名。例如： 使用对应的公钥/私钥，您可以确定发件人是否是他们说的人。此外，由于使用 http header 和有效负载计算签名，您还可以验证内容是否被篡改。 JSON web Token 的结构在其紧凑的形式中，JSON web Token由三部分组成（由（.）分隔）如下： Header Payload Signature JWT 的表示通常如：HHHH.PPPP.SSSS Header 标头通常由两部分组成： token 的类型，即 JWT，以及正在使用的散列算法，例如：HMAC SHA256 或 RSA 1234&#123; "alg": "RSA", "typ": "JWT"&#125; 接着，这个 JSON 被编码成 BASE64URl，形成 JWT 的第一部分 Payload token 的第二组成部分，其中包含声明。声明是关于实体（通常是用户）和其他数据的声明。索赔由三种类型：注册，公开和私人索赔。 已经注册了的声明: 这些是一组预定义的声明，不是强制性的，但建议使用，以提供一组有用的，可相互操作的声明。例如（部分）： iss： 发行人 exp： 到期时间 sub： 主题 aud： 观众注意： 声明名称只有三个字符，因为 JWT 意味着紧凑 公开声明： 这些可以由使用 JWT 的人随意定义。但是为规避冲突，应在 IANA JSON Web Token 注册表中定义他们，或者将其定义为包含防冲突命名空间的 URL。 私人索赔： 这是创建共享统一使用它们，并既不是当事人之间的信息自定义声明注册或公众的权力要求。 示例： 12345&#123; "sub": "1234567890", "name": "John Doe", "admin": true&#125; 然后，有效负载经过 Base64Url 编码，形成 JSON Web 令牌的第二部分 请注意，对于签名令牌，此信息虽然可以防止被篡改，但任何人都可以读取。除非加密，否则不要将秘密信息放在 JWT 的有效负载或头元素中。 Signature 要创建签名部分，您必须采用编码标头，编码的有效负载，秘密，标头中指定的算法，并对其进行签名 例如，如果要使用 HMAC SHA256 算法，将按以下方式创建签名： 1234HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret) 签名用于验证消息在此过程中未被更改，并且，在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发件人是否是它所声称的人。 把三个部分组合到一起 输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，与 SAML 等基于 XML 的标准相比更加紧凑 例如： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c JSON Web Token 如何工作？ 在身份验证中，当用户使用其凭据成功登陆时，将返回 JSON Web Token。由于 token 是凭证，因此必须非常小心以防止出现安全问题，一般情况下，您不应该将令牌保留的时间超过要求。 每当用户想要访问受保护的路由或者资源时，用户代理应该使用Bearer模式发送JWT，通常在Authorition标头中，表头的内容如下： 1Authorization: Bearer &lt;token&gt; 在某些情况下，这可以是无状态授权机制，服务器的受保护路由将检查 Authorization 标头中有效的 JWT，如果存在，则允许用户访问受保护资源。如果 JWT 包含必要的数据，则减少查询数据库以进行某些操作的需要，尽管可能并非总是如此。如果在标Authorization头中发送令牌，则跨域资源共享（CORS）将不会成为问题，因为它不使用 cookie。 下图显示了如何获取JWT并用于访问API或资源： &lt;% img /public/images/client-credentials-grant.png %&gt; 1.应用程序或客户端向授权服务器请求授权。这是通过其中一个不同的授权流程执行的。例如，典型的 OpenID Connect 兼容 Web 应用程序将/oauth/authorize 使用授权代码流通过端点。 授予授权后，授权服务器会向应用程序返回访问令牌。 应用程序使用访问令牌来访问受保护资源（如 API）。 请注意，使用签名令牌，令牌中包含的所有信息都会向用户或其他方公开，即使他们无法更改。这意味着您不应该在令牌中放置秘密信息。 我们为什么要使用 JSON Web Toaken 让我们来谈谈域简单 web token （SWT）和安全断言标记语言令牌（SAML）相比，JSON Web Toaken （JWT）的好处 由于JSON比XML更简洁，因此在编码时它的大小也更小，使得JWT比SAML更紧凑。这使得JWT成为在HTML和HTTP环境中传递的不错的选择 在安全方面，SWT只能使用HMAC算法通过共享密钥对称签名。但是，JWT和SAML token可以使用X.509证书形式的公钥/私钥进行签名，与签名JSON的简单性相比，使用XML数字签名对XML进行签名而不会进入模糊的安全漏洞非常困难 JSON解析器在大多数编程语言中很常见，因为它们直接映射到对象，相反，XML没有自然的文档到对象映射。这使得使用JWT比使用SAML断言更容易 关于使用，JWT用户互联网规模，这突出了在多个平台（尤其是移动平台）上轻松进行（JSON web Token）的客户端处理 &lt;% img /public/images/comparing-jwt-vs-saml2.png %&gt; 比较编码的 JWT 和编码的 SAML 的长度 linksJSON Web Token]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JSON</tag>
        <tag>Token</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5有哪些新特性，移除了哪些元素？如何处理HTMl5新标签的浏览器兼容性？如何区分HTML和HTML5？]]></title>
    <url>%2F2018%2F12%2F11%2F2018-12-11-HTML5%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[首先在解释以下什么是 HTML5 之前，我们先来了解以下，什么是 SGML？ SGML(standard generalized Markup language) 标准通用标记语言 wiki 上面对 SGML 的解释是：现时常用的超文本格式的最高层次标准，是可以定义标记语言的元语言，甚至可以定义不必采用 &lt; &gt; 的常规方式。同时它也是一个 ISO 标准：”ISO 8879:1986 Information processing – Text and office systems – Standard Generalized Markup Language (SGML)”。HTML 和 XML 同样派生于它，XML 可以认为是它的一个自己，HTML 可以认为是它的一个应用。 wiki 对 HTML5 的解释是： 广义论 HTML5 实际指的是 html+css+JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需求插件的丰富性网络应用服务。（例如 Adobe Flash， MIcrosoft Silverlight 等等） HTML5 已经不是 SGML 的子集了，主要是关于新标签元素，新媒体，定位，图形，存储，新的 API 等的增加。 图形 canvas 和 SVG 用于媒体播放的 &lt;audio&gt;, &lt;embed&gt;, &lt;source&gt;, &lt;track&gt;, &lt;video&gt; 本地离线存储 localStorage（永久存储） 和 sessionStorage（临时存储） 8 个新语义化标签： header, section, footer, aside, nav, main, article, figure 表单控件： &lt;datalist&gt; &lt;output&gt; input 类型和属性: new input type: color date datetime datetime-local email month number range search tel time url week new input Attributes: autocomplete autofocus form formaction formenctype formmethod formnovalidate formtarget height and width list min and max multiple pattern (regexp) placeholder required step 新的 JavaScript API：web worker, Drag and Drop, Local Storage,SSE, geolocation, Application Cache, WebSocket 移除的元素 纯表现的元素：acronym applet basefont big center font s strike tt dir 负面影响的元素： frame, frameset, noframes 支持 HTML5 IE9 之前（IE6+ ）你可以使用 JavaScript 语句 document.createElement(‘myCreate’) 需要注意的是，IE8(及更早的版本) 不允许使用未知元素的样式 最完美的解决方案是使用 HTML5shiv，直接飞github html5shiv, 语法如下： 123&lt;head&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="/js/html5shiv.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; 区分 HTML5： DOCTYPE 声明\新增的结构元素\功能元素]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html & css面试]]></title>
    <url>%2F2018%2F12%2F10%2F2018-12-10-html%26css%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[HTML——————————test 页面导入样式时，使用 link 和@import 有什么区别？ link 属于 XHTML 标签，处理加载 css 以为，还可以有 RSS 及 rel 属性等等，@import 是 css 提供的，仅支持引入 css； 页面被加载时，link 会同时被加载，而@import 必须等页面加载完毕再加载； @import 是 css2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题； link 支持使用 js 控制 DOM 去改变样式，而@import 不支持； 浏览器的内核 浏览器的内核主要分为两个部分：渲染引擎，js 引擎 trident 内核：IE，360，搜狗等 gecko 内核：Netscape6 及以上版本，FF，MozillaSuite prosto 内核：Opera7 及以上，【opera 内核原为 presto，现在改为 blink】 webkit 内核：safari，chrome 等 【chrome：webkit 分支—-blink】 edge 浏览器：渲染引擎–edgeHTML，js 引擎–chakra 请描述一下，cookie，sessionStorage 和 localStorage 的区别？ cookie 是为了表示用户身份而存储再用户本地终端上的数据（通常经过加密）cookie 数据始终在同源的 http 请求中携带（即使不需要），即会在浏览器和服务器间来回传递seesionStroage 和 localStorage 不会自动把数据发给服务器，仅在本地保存； 存储大小cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 可以达到 5M 有效时间localStorage 存储持久数据，主动删除sessionStrorage 数据在当前浏览器关闭后自动删除cookie 设置的 cookie 国企时间之前一直有效，即使窗口关闭或者浏览器关闭 HTML5 的 form 如何关闭自动完成？ 在 form 或者里面的 input 标签上添加: autoComplete=off 如何在页面上实现一个圆形的点击区域？ map + area 或者 svg border-radius 纯 js 实现 1px 问题？ https://www.jianshu.com/p/d62d22b44ce4]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>HTML5</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM 事件]]></title>
    <url>%2F2018%2F12%2F10%2F2018-12-10-DOM%20%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[“Yeah It’s on. ” DOM 事件基本概念 DOM 使 JavaScript 有能力对 HTML 上的事件做出反应 DOM事件的级别 DOM0 —————element.click = function(){} DOM2 —————element.addEventListener(‘click’, function(){}) DOM3 —————element.addEventListener(‘keyup’, function(){}) DOM 事件模型 DOM 的事件模型分为两种，一类是 IE 的冒泡事件模型，一类是 DOM 标准定义的冒泡与捕获类型 DOM 事件流事件流： window –&gt; 捕获 –&gt; 目标阶段 –&gt; 冒泡 –&gt; window 描述 DOM 事件捕获的具体流程&lt;% img /public/images/eventflow.svg %&gt; Event 对象的常见应用12345event.preventDefault() // 阻止默认事件event.stopPropagation() // 阻止事件冒泡event.stopImmediatePropagation() // 事件响应优先级event.currentTarget // 当前绑定的事件对象event.current 自定义事件js 的观察者模式创建自定义事件 Event()构造函数，创建一个新的事件对象 event CustomEvent（）创建一个自定义事件 document.CreateEvent()创建一个心的事件对象 event，随之调用自身的 init 方法进行初始化 12345678// 创建事件var create = document.createEvent('event')// 定义事件名称为buildelement.addEventListener('build', function(e)&#123; console.log(e)&#125;, false)// 触发对象可以是任何元素或者其他事件目标element.dispatchEvent(event) 封装自定义事件 123456789101112131415(function()&#123; try&#123; new window.CustomEvent('T') &#125;catch(e)&#123; var CustomEvent = function(event, params) &#123; params = params || &#123; bubbles: false, cancelable: fasle, detail: undefind &#125; var evt = document.createEvent('CustomEvent') evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail) return evt; &#125; CustomEvent.prototype = window.Event.prototype window.CustomEvent = CustomEvent &#125;&#125;)()]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>DOM</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议详解]]></title>
    <url>%2F2018%2F12%2F07%2F2018-08-15-HTTP%2F</url>
    <content type="text"><![CDATA[HTTP 协议 http 协议的主要特点 简单快速， 灵活， 无状态， 无连接 http 报文的组成部分 请求报文 请求行，请求头，空行，请求体 响应报文 状态行，响应头，空行，响应体 HTTP 方法 POST 传输资源 GET 获取资源 DELETE 删除资源 PUT 更新资源 HEAD 获得报文首部 POST 与 GET 的区别 GET 在浏览器回退是无害的，而 POSt 会再次请求 * GET 产生的 url 地址可以被收藏，而 post 不可以 GET 请求会被浏览器主动缓存，而 POST 不会，除非你主动收藏 * GET 请求只能进行 url 编码，而 POST 支持多种编码方式 GET 请求参数会被完整保留在浏览器历史记录里，而 post 中的参数不会被保留 * GET 请求在 URL 中传送参数是有长度限制的，而 POST 没有限制 * 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制 GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息 GET 参数通过 URL 传递，POST 放在 Reuerst body 中 * get 与 post 区别 post 与 get 请求 HTTP 状态码 100-199 信息性状态码200-299 成功状态码300-399 重定向状态码400-499 客户端状态码500-599 服务器状态码 常用状态码 200 成功 206 请求部分资源成功 301 当前请求重定向 302 请求的所有资源都重定向 304 已有缓存，可以继续使用 400 客户端请求语法错误，不能被服务端解析 401 请求未经授权 403 对请求页面的访问被禁止 404 请求资源不存在 500 服务器错误 503 请求未完成，服务器临时过载或当机 什么是持久化链接 持久化连接减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务端的压力；另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早的结束，这样 web 页面的显示速度也就相应的提高了。http 版本 1.1 支持 keep-Alive 什么是管线化 原理 建立在 keep-Alive 的基础上，将请求打包发出去，再将响应打包发回来管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术只有 get 和 head 请求可以进行管线化，而 post 则有限制初次连接的时候不应启动管线化，因为服务器不一定支持 cookie 的状态管理 没有 cookie 状态下的请求 第二次以后（存在 cookie 信息状态）的请求]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组常用方法]]></title>
    <url>%2F2018%2F12%2F07%2F2019-01-08-%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[数组常用方法 遍历数组— forEach 123arr.forEach(item, i, array)&#123; console.log(item, i)&#125; 添加元素到数组的末尾 — push 1arr.push('apple') 删除元素在数组的末尾— pop 1arr.pop() 添加元素到数组的开始 — unshift 1arr.unshift('dog') 删除数组最前面的元素 1arr.shift() 指出某个元素在数组中的索引 1let inx = arr.indexOf('zander') 通过索引删除某个元素/多个元素 12let idx = 2arr.splice(idx, 1) 复制一个数组 1arr.slice() 判断一个变量是否是数组对象 1Array.isArray(arr) 从类数组对象或者可迭代对象中创建一个新的数组实例 1Array.from(obj) 根据一组参数来创建新的数组实例，支持任意的参数数量和类型 1Array.of('1', '2', 3) 颠倒数组中的排列顺序 1arr.reverse() 数组合并 1arr1.concat(arr2) 连接所有数组元素组成一个字符串 1arr.json(' ') 返回一个由数组元素而组成的字符串 1arr.toString() 返回数组中第一个与指定值相等的元素索引，如果找不到这样的元素，就返回 -1 1arr.indexOf(item) 如果数组中的每一个元素都满足测试函数，则返回 true，否则返回 false 123arr.every(function(item, i, array) &#123; // dosomething&#125;) 数组中至少有一个元素满足测试函数，则返回 true，否则返回 false 123arr.some(function(item, i, array) &#123; // to do something&#125;) 将所有在过滤函数中返回 true 的数组元素放入到一个新的数组中并返回 123arr.filter(function(item, i, arr) &#123; // to do something&#125;) 返回一个由回调函数组成的数组 123arr.map(function(element, index, array) &#123; // to do something&#125;) every some filter map reduce from of copyWidthin find &amp;&amp; findIndex fill entries() &amp;&amp; keys() &amp;&amp; values() includes() flat() &amp;&amp; flatMap()]]></content>
      <categories>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
